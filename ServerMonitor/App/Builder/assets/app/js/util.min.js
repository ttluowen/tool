/**
 * 小工具。
 * 会将 util 注册到全局。
 *
 * @since 2018-01-26
 * @version 1.0
 * @author Luowen
 */

((function util() {
	var _util = window.util || {};

	// 添加到全局。
	var oUtil = window.util = {
		/**
		 * 解决 util 冲突处理。
		 * 返回小工具对象，由开发人员自己处理。
		 *
		 * @method
		 * @return {Object}
		 */
		conflict: function() {
			window.util = _util;
			return oUtil;
		},

		/**
		 * 检测数字类型。
		 *
		 * @param {Object} o
		 * @param {Object} type
		 */
		istype: function(o, type) {
			if(type) {
				var _type = type.toLowerCase();
			}
			switch(_type) {
				case 'string':
					return Object.prototype.toString.call(o) === '[object String]';
				case 'number':
					return Object.prototype.toString.call(o) === '[object Number]';
				case 'boolean':
					return Object.prototype.toString.call(o) === '[object Boolean]';
				case 'undefined':
					return Object.prototype.toString.call(o) === '[object Undefined]';
				case 'null':
					return Object.prototype.toString.call(o) === '[object Null]';
				case 'function':
					return Object.prototype.toString.call(o) === '[object Function]';
				case 'array':
					return Object.prototype.toString.call(o) === '[object Array]';
				case 'object':
					return Object.prototype.toString.call(o) === '[object Object]';
				case 'nan':
					return isNaN(o);
				case 'elements':
					return Object.prototype.toString.call(o).indexOf('HTML') !== -1
				default:
					return Object.prototype.toString.call(o)
			}
		},

		/**
		 * 获取指定 URL 的参数。
		 *
		 * @method
		 * @param {String} sParamName
		 * @param {String} sUrl
		 * @return {String|undefined}
		 */
		getParam: function(sParamName, sUrl = location.href) {
			return this.getParams(sUrl)[sParamName];
		},

		/**
		 * 获取 URL 中所有参数信息。
		 *
		 * @method
		 * @param {String|undefined} sUrl [{location.href}]
		 * @return {Object}
		 */
		getParams: function(sUrl = location.href) {
			// 过滤后面的锚点。
			sUrl = sUrl.replace(/#.*/g, "");
			// 取出 ? 后面的参数串。
			sUrl = sUrl.split("?")[1] || "";

			var oParam = {};
			sUrl.split("&").forEach(function(sItem) {
				var asParam = sItem.split("=");
				oParam[asParam[0]] = decodeURIComponent(asParam[1]);
			});

			return oParam;
		},

		/**
		 * 返回指定 URL 中是否包含指定参数。
		 *
		 * @method
		 * @param {String} sParamName
		 * @param {String|undefined} sUrl
		 * @return {Boolean}
		 */
		hasParam: function(sParamName, sUrl = location.href) {
			return this.getParam(sParamName, sUrl) !== undefined;
		},

		/**
		 * 添加指定参数到指定 URL。
		 *
		 * @method
		 * @param {String} sParamName
		 * @param {String|undefined} sValue
		 * @param {String} sUrl
		 */
		setParam: function(sParamName, sValue, sUrl = location.href) {
			let oData = {};
			oData[sParamName] = sValue;

			return this.setParams(oData, sUrl);
		},

		/**
		 * 添加多个参数到指定 URL。
		 *
		 * @method
		 * @param {String} oParams
		 * @param {String|undefined} sUrl
		 * @return {String}
		 */
		setParams: function(oParams, sUrl = location.href) {
			let _this = this,
				sUri = sUrl.split("?")[0],
				oParamData = _this.getParams(sUrl);

			// 合并。
			Object.assign(oParamData, oParams);
			// 重新转换回来。
			let sParams = _this.toParams(oParamData);

			if(sParams) {
				return sUri + "?" + sParams;
			} else {
				return sUri;
			}
		},

		/**
		 * 删除指定的参数。
		 *
		 * @param {String} sParamName
		 * @param {String|undefined} sUrl
		 * @return {String}
		 */
		removeParam: function(sParamName, sUrl = locaiton.href) {
			var REMOVE_VALUE = "remove";

			return this.setParam(sName, REMOVE_VALUE, sHref)
				.replace(new RegExp("([\?&]?)" + sName + "=" + REMOVE_VALUE + "[&]?", "g"), "$1") // 过滤对应的参数项。
				.replace(/&$/, "") // 过滤最后一个多的 & 符号。
			;
		},

		/**
		 * 删除多个 URL 参数。
		 *
		 * @param {Array} asParamNames
		 * @param {String|undefined} sUrl
		 * @return {String}
		 */
		removeParams: function(asParamNames, sUrl = location.href) {
			var _this = this,
				_url = sUrl;

			asParamNames.forEach((sParam) => {
				_url = _this.removeParam(sParam, _url);
			});

			return _url;
		},

		/**
		 * 将对象转换成 URL 参数，并对字符进行转义。
		 *
		 * @method
		 * @param {Object} oData
		 * @return {String}
		 */
		toParams: function(oData) {
			var asParams = [];

			oData.keys().forEach((sKey) => {
				asParams.push(sKey + "=" + encodeURIComponent(oData[sKey]));
			});

			return asParams.join("&");
		},

		/**
		 * 占位符替换工厂。
		 *
		 * @method
		 * @param {String} sContent 含占位符的字符串。
		 * 	当要被替换的内容中含未知替换数据，则会保留当前点位符。
		 * @param {Object} oData 要替换的点位符数据，依据对象的键名与点位符一一对应，功能类似 KISSY.substitute。
		 * @param {String} sUnValue 当值为空、null、NaN 等无效值时，使用该值来替代，如果该值也无效，则会继续使用原来的值。
		 * @return {String} 返回替换后的字符串。
		 */
		substitute: function(sContent, oData, sUnValue) {
			if(!oData) {
				return sContent;
			}

			var sValue = "";
			for(var p in oData) {
				sValue = oData[p];
				if(!sValue && sUnValue != undefined) {
					sValue = sUnValue;
				}

				sContent = sContent.replace(new RegExp("\\{" + p + "\\}", "g"), sValue);
			}

			return sContent;
		},

		/**
		 * 生成一个 32 位的 id。
		 * 依赖 md5.min.js
		 * 
		 * @return {String}
		 */
		gid: function() {
			let _this = this;

			return _this.md5(new Date + "," + _this.random(1000, 9999)) || _this.gsid(32);
		},

		/**
		 * 生成一个 16 位的 id。
		 * 依赖 md5.min.js
		 * 
		 * @return {String}
		 */
		gid16: function() {
			return this.gid().substr(8, 24);
		},

		/**
		 * 使用 MD5 进行加密。
		 * 依赖 md5.min.js
		 * 
		 * @param {String} sValue
		 * @param {String|undefined} sKey
		 * @param {Boolean|undefined} bRaw
		 * @return{String}
		 */
		md5: function(sValue, sKey, bRaw) {
			return window.md5 && md5(sValue, sKey, bRaw).toUpperCase() || null;
		},

		encode: function(sValue) {
			return btoa(encodeURIComponent(sValue).replace(/%([0-9A-F]{2})/g,
				function toSolidBytes(match, p1) {
					return String.fromCharCode('0x' + p1);
				}));
		},

		decode: function(sCode) {
			return decodeURIComponent(atob(sCode).split('').map(function(c) {
				return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
			}).join(''));
		},

		/**
		 * 随机生成一个[a-zA-Z0-9]的编码，默认返回8位。
		 *
		 * @method
		 * @param {Number|undefined} nSize
		 * @return {String}
		 */
		gsid: function(nSize = 8) {
			var asBase = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".split(""),
				nLength = asBase.length,
				asId = [];

			while(nSize-- > 0) {
				asId.push(asBase[Math.floor(Math.random() * nLength)]);
			}

			return asId.join("");
		},

		/**
		 * 设置数量显示位，不足指定位用前面用零填充。
		 *
		 * @method fix
		 * @param {Number} nValue 数值。
		 * @param {Number|undefined} nSize 显示的数位。(2)
		 * @return {String}
		 */
		fix: function(nValue, nSize = 2) {
			let nOffset = nSize - String(sValue).length;
			if(nOffset < 0) {
				nOffset = 0;
			}

			return "0".repeat(nOffset) + nValue;
		},

		/**
		 * 生成一个 [min, max] 之间的值。
		 * 
		 * @param {Number} nMin 最小时，包含。
		 * @param {Number} nMax 最大值，包含。
		 * @return {Number}
		 */
		random: function(nMin, nMax) {
			return Math.round(Math.random() * (nMax - nMin) + nMin);
		},

		/**
		 * 将字符串时间转换成时间对象。
		 *
		 * @param {String|Date|Number} sDateTime
		 *  字符串类型参数，支持格式如下：
		 *  UTC 标准时间
		 *
		 *  yyyy-MM-dd hh:mm:ss
		 * 	yyyy-MM-dd
		 *
		 *  MM-dd hh:mm
		 *
		 *  hh:mm:ss
		 *
		 *  MM-dd
		 *  hh:mm
		 *
		 *  yy-MM-dd hh:mm:ss
		 *  yy-MM-dd
		 *
		 * @return {Date}
		 */
		parseDate: function(sDateTime) {
			var dDate = null,
				sDateType = $.type(sDateTime);

			// 检测参数类型。
			if($.isDate(sDateTime)) {
				// 日期对象型。

				dDate = sDateTime;
			} else if($.isNumeric(sDateTime)) {
				// 毫秒值类型。

				dDate = new Date(Number(sDateTime));
			} else if($.isString(sDateTime)) {
				// 字数串类型。
				sDateTime = sDateTime.replace(/-/g, "/");
				// 首先使用标准日期格式来实例化。
				dDate = new Date(sDateTime);

				/*
				 * 如果是无效的日期，则再进一步分析，否则可直接使用。
				 * 或者是非 yy-MM-dd 的三段日期，两段的也不行。
				 */
				if(dDate.toString() == "Invalid Date" || sDateTime.split("/").length < 3) {
					var asDate = [],
						asTime = [];

					// 分割日期与时间。
					var asDateTime = sDateTime.split(" ");
					var sSplitedDate = asDateTime[0];

					// 检测分割结果段数。
					if(asDateTime.length == 2) {
						// 有两段，则参数包括日期和时间。

						asDate = sSplitedDate.split("/");
						asTime = sDateTime[1].split(":");
					} else {
						// 不是两段，当作只有日期或时间来处理。

						// 检测分割后的日期里，是否有(-)符号，如果有则表示这段是日期的，否则为时间的。
						if(sSplitedDate.indexOf("/") > -1) {
							// 日期型。

							asDate = sSplitedDate.split("/");
						} else {
							// 时间型。

							asTime = sSplitedDate.split(":");
						}
					}

					var nNow = new Date(),

						// 日期段没传则使用当天。
						nYear = nNow.getFullYear(),
						nMonth = nNow.getMonth(),
						nDay = nNow.getDate(),

						// 时间段没传则使用零点。
						nHours = 0,
						nMinutes = 0,
						nSeconds = 0;

					// 检测分割后的日期段，是否有值。
					if(asDate.length) {
						if(asDate.length == 3) {
							// 三段式日期。

							nYear = asDate[0] >> 0;
							nMonth = asDate[1] >> 0;
							nDay = asDate[2] >> 0;
						} else {
							// 两段式日期。

							nMonth = asDate[0] >> 0;
							nDay = asDate[1] >> 0;
						}

						// 如果参数传的年是两位数，则换算成四位整年。
						if(nYear < 1900) {
							nYear += 1900;
						}

						// 月份要减一。
						nMonth--;
					}

					// 检测分割后的时间段，是否有值。
					if(asTime.length) {
						nHours = asTime[0] >> 0;
						nMinutes = asTime[1] >> 0;

						// 三段式的值，表示包括毫秒。
						if(asTime.length == 3) {
							nSeconds = asTime[2] >> 0;
						}
					}

					// 实例段日期对象。
					dDate = new Date(nYear, nMonth, nDay, nHours, nMinutes, nSeconds);
				}
			}

			return dDate;
		},

		/**
		 * 格式化日期时间。
		 * 如 yyyy-MM-dd、yyyy-MM-dd hh:mm:ss
		 *
		 * @param {String|Date|Number} dDate 要格式化的日期对象。
		 * @param {String} sTemplate 要模式化的模板。
		 *  y 年
		 *  M 月
		 *  d 日
		 *  h 时
		 *  m 分
		 *  s 秒
		 *  S 毫秒
		 *  q 季
		 *  w 周
		 * @return {String}
		 */
		formatDate: function(dDate, sTemplate) {
			// 先解析一下日期参数。
			dDate = this.parseDate(dDate);

			// 检测解析有效性。
			if(!dDate) {
				return "";
			}

			var
				nFullYear = dDate.getFullYear(), // 四位整年。
				nYear = nFullYear.toString().substring(2), // 两位年。
				nMonth = dDate.getMonth() + 1, // 月份。
				nDay = dDate.getDate(), // 日。

				nHours = dDate.getHours(), // 时。
				nMinutes = dDate.getMinutes(), // 分。
				nSeconds = dDate.getSeconds(), // 秒。

				nMilliseconds = dDate.getMilliseconds(), // 毫秒。
				nQuarter = Math.floor((nMonth + 3) / 3), // 季。
				nWeek = _iso8601Week(dDate), // 周

				fix = this.fix;

			var oFullFlags = {
				yyyy: nFullYear, // 年。
				MM: fix(nMonth), // 月。
				dd: fix(nDay), // 日。
				hh: fix(nHours), // 时。
				mm: fix(nMinutes), // 分。
				ss: fix(nSeconds), // 秒。
				S: nMilliseconds, // 毫秒。
				q: nQuarter, // 季。
				w: nWeek
			};

			var oFlags = {
				yy: nYear, // 年。
				M: nMonth, // 月。
				d: nDay, // 日。
				h: nHours, // 时。
				m: nMinutes, // 分。
				s: nSeconds // 秒。
			};

			// 逐一替换各属性。
			var sDate = sTemplate;

			// 先替换多位的。
			for(var p in oFullFlags) {
				sDate = sDate.replace(p, oFullFlags[p]);
			}

			// 再替换单位的。
			for(var p in oFlags) {
				sDate = sDate.replace(p, oFlags[p]);
			}

			return sDate;

			/**
			 * 计算当前日期为当年的第几周
			 *
			 * @param {Date} date
			 * @return {Number}
			 */
			function _iso8601Week(date) {
				var time, checkDate = new Date(date.getTime());

				// Find Thursday of this week starting on Monday
				checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

				time = checkDate.getTime();
				checkDate.setMonth(0); // Compare with Jan 1
				checkDate.setDate(1);
				return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
			}
		},

		/**
		 * 计算目标时间与起始时间的时间差，反按指定模板格式返回。
		 *
		 * @param {Date} dTargetDate
		 * @param {Date|undefined} sBeginDate
		 * @param {String|undefined} sTemplate
		 * @return {String}
		 */
		dateOffset: function(dTargetDate, dBeginDate = new Date(),
			sTemplate = "剩余时间:{d}天{h}小时{m}分钟{s}秒") {

			var t = dTargetDate.getTime() - dBeginDate.getTime(); //时间差的毫秒数
			var d = 0,
				h = 0,
				m = 0,
				s = 0;
			if(t >= 0) {
				d = Math.floor(t / 1000 / 3600 / 24);
				h = Math.floor(t / 1000 / 60 / 60 % 24);
				m = Math.floor(t / 1000 / 60 % 60);
				s = Math.floor(t / 1000 % 60);
			}

			return "剩余时间:" + d + "天" + h + "小时" + m + "分钟" + s + "秒";
		},

		/**
		 * 过去了的时间。
		 *
		 * @param {Object} dateStr
		 */
		timeAgo: function(dateStr) {
			//dateStr格式：2017-08-17 10:39:27
			//转换成时间戳
			var dateTimeStamp = Date.parse(dateStr.replace(/-/gi, "/"));
			var minute = 1000 * 60;
			var hour = minute * 60;
			var day = hour * 24;
			var month = day * 30;
			var now = new Date().getTime();
			var diffValue = now - dateTimeStamp;
			if(diffValue < 0) {
				return;
			}
			var monthC = diffValue / month;
			var dayC = diffValue / day;
			var hourC = diffValue / hour;
			var minC = diffValue / minute;
			var result;
			if(monthC >= 12) {
				result = dateStr;
			} else if(monthC >= 1) {
				result = "" + parseInt(monthC) + "个月前";
			} else if(dayC >= 1) {
				result = "" + parseInt(dayC) + "天前";
			} else if(hourC >= 1) {
				result = "" + parseInt(hourC) + "小时前";
			} else if(minC >= 1) {
				result = "" + parseInt(minC) + "分钟前";
			} else if(minC < 1) {
				result = "刚刚";
			}

			return result;
		},

		/**
		 * 字节单位转换。
		 * 
		 * @param {Number} nBytes
		 * @return {String}
		 */
		bytesToSize: function(nBytes) {
			if(nBytes === 0) return '0 B';

			var k = 1024,
				sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
				i = Math.floor(Math.log(nBytes) / Math.log(k));

			return(nBytes / Math.pow(k, i)).toPrecision(3) + ' ' + sizes[i];
		},

		/**
		 * Rgb 颜色 转化为 16进制颜色。
		 * @param {Object} sRgb
		 * @return {String} strHex
		 */
		colorHex: function(sRgb) {
			var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
			var that = sRgb;
			if(/^(rgb|RGB)/.test(that)) {
				var aColor = that.replace(/(?:\(|\)|rgb|RGB)*/g, "").split(",");
				var strHex = "#";
				for(var i = 0; i < aColor.length; i++) {
					var hex = Number(aColor[i]).toString(16);
					if(hex === "0") {
						hex += hex;
					}
					strHex += hex;
				}
				if(strHex.length !== 7) {
					strHex = that;
				}
				return strHex;
			} else if(reg.test(that)) {
				var aNum = that.replace(/#/, "").split("");
				if(aNum.length === 6) {
					return that;
				} else if(aNum.length === 3) {
					var numHex = "#";
					for(var i = 0; i < aNum.length; i += 1) {
						numHex += (aNum[i] + aNum[i]);
					}
					return numHex;
				}
			} else {
				return that;
			}
		},

		/**
		 * 16进制 颜色 转化为 Rgb颜色。
		 * @param {Object} sHex
		 * @return {String} sColor
		 */
		colorRgb: function(sHex) {
			var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
			var sColor = sHex.toLowerCase();
			if(sColor && reg.test(sColor)) {
				if(sColor.length === 4) {
					var sColorNew = "#";
					for(var i = 1; i < 4; i += 1) {
						sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
					}
					sColor = sColorNew;
				}
				//处理六位的颜色值
				var sColorChange = [];
				for(var i = 1; i < 7; i += 2) {
					sColorChange.push(parseInt("0x" + sColor.slice(i, i + 2)));
				}
				return "rgb(" + sColorChange.join(",") + ")";
			} else {
				return sColor;
			}
		},

		/**
		 * 检测内容是否是指定类型的。
		 *
		 * @param {String} sContent
		 * @param {String} type email、phone、tel、number、english、text、chinese、lower、upper
		 * @return {Boolean}
		 */
		checkStringType: function(sContent, sType) {
			switch(sType) {
				case 'email':
					return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(sContent);
				case 'phone':
					return /^1[3|4|5|7|8][0-9]{9}$/.test(sContent);
				case 'tel':
					return /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(sContent);
				case 'number':
					return /^[0-9]$/.test(sContent);
				case 'english':
					return /^[a-zA-Z]+$/.test(sContent);
				case 'text':
					return /^\w+$/.test(sContent);
				case 'chinese':
					return /^[\u4E00-\u9FA5]+$/.test(sContent);
				case 'lower':
					return /^[a-z]+$/.test(sContent);
				case 'upper':
					return /^[A-Z]+$/.test(sContent);
				default:
					return true;
			}
		},

		/**
		 * 数组去重。
		 *
		 * @param {Array} oArray
		 * @return {Array}
		 */
		noRepeat: function(oArray) {
			return Array.from(new Set(oArray));
		},

		/**
		 * 从数据中删除指定值。
		 *
		 * @param {Object} arr
		 * @param {Object} val
		 * @param {Object} type
		 */
		removeArrayOfVal: function(arr, val, type) {
			return arr.filter(function(item) {
				return type ? item.indexOf(val) === -1 : item !== val;
			})
		},

		/**
		 * 从数据中删除指定索引位置的值。
		 *
		 * @param {Object} arr
		 * @param {Object} index
		 */
		removeArrayOfIndex: function(arr, index) {
			if(index > arr.length - 1 || index < 0) {
				return arr;
			}
			var arr1 = [];
			for(var i = 0; i < arr.length; i++) {
				if(i == index) {
					continue;
				}
				arr1.push(arr[i]);
			}
			arr.length = 0;
			for(var j = 0; j < arr1.length; j++) {
				arr[j] = arr1[j];
			}
			return arr;
		},

		/**
		 * 获取指定名称的 Cookie 值。
		 * 
		 * @param {String} sName
		 * @return {String}
		 */
		getCookie: function(sName) {
			var sCookie = document.cookie;

			if(sCookie) {
				// 分割出所有 Cookie 项。
				var asCookies = sCookie.split(";");
				var asItem;

				// 遍历逐一找指定名称的那个项。
				for(var i = 0, l = asCookies.length; i < l; i++) {
					// 将当前项名称和值分割。
					asItem = asCookies[i].trim().split("=");

					// 名称匹配检测。
					if(asItem[0] == sName) {
						return decodeURIComponent(asItem[1]);
					}
				}
			}

			return "";
		},

		/**
		 * 写入或删除 Cookie 值。
		 * 
		 * @param {String} sName
		 * @param {String} sValue
		 * @param {Object} oOptions
		 */
		setCookie: function(sName, sValue, oOptions) {
			if(!oOptions) {
				oOptions = {};
			}

			// 假如要设置的值为 null，则作删除操作。
			if(sValue === null || sValue === undefined || sValue === "") {
				sValue = "";
				oOptions.expires = -1; // 设置过去的时间，以使 cookie 马上过期。
			}

			// 根据参数判断过期时间。
			var sExpires = oOptions.expires;

			// 如果过期时间未设置，默认一年后过期。
			if(!sExpires) {
				sExpires = 365;
			}

			// 检测参数类型。
			var sArgumentType = (typeof sExpires).toLowerCase();
			if(sArgumentType == "number") {
				// 数字型。

				// 添加天数。
				var dDate = new Date();
				dDate.setTime(dDate.getTime() + (sExpires * 24 * 60 * 60 * 1000));

				sExpires = dDate.toUTCString();
			} else if(sArgumentType == "date") {
				// 日期型。

				sExpires = sExpires.toUTCString();
			}

			// 过期时间。
			sExpires = "; expires=" + sExpires;
			// 路径。
			var sPath = oOptions.path ? "; path=" + (oOptions.path) : "";
			// 域。
			var sDomain = oOptions.domain ? "; domain=" + (oOptions.domain) : "";
			// 加密。
			var sSecure = oOptions.secure ? "; secure" : "";

			// 写入到 Cookie。
			document.cookie = [sName, "=", encodeURIComponent(sValue), sExpires, sPath, sDomain, sSecure].join("");
		},

		/**
		 * 删除指定 Cookie。
		 * 
		 * @param {String} sName
		 * @param {Object|undefined} oOPtions
		 * returnl {void}
		 */
		removeCookie: function(sName, oOptions) {
			this.setCookie(sName, null, oOptions);
		},

		/**
		 * 生成一个临时的设备标记。
		 * 
		 * @return {String}
		 */
		device: function() {
			return "pc-" + this.gid16();
		},
		
		
		/**
		 * 指定延迟时间后执行的动作。
		 * 
		 * @param {Number} nTimeout 单位毫秒。
		 * @param {Function} fnTodo 函数句柄。
		 * @return {Number} setTimeout 的定时器。
		 */
		timeout: function(nTimeout, fnTodo) {
			return setTimeout(fnTodo, nTimeout);
		}
	};
}))();