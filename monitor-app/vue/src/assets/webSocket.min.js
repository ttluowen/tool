/**
 * 套接字服务，常用的连接等，断开会在指定时间内自动重连。
 * 
 * @since 2017-02-20
 * @version 1.0
 * @author Luowen
 */


((function webSocket() {
	/**
	 * 默认配置信息。
	 */
	var DEFAULT_CONFIGS = {
		/**
		 * WebSocket 服务地址。
		 * ws:// 协议的。
		 * 
		 * @type {String}
		 */
		url: "",
		
		/**
		 * 断开是否自动重连。
		 * 
		 * @type {Boolean}
		 */
		autoReconnect: true,

		/**
		 * 断开后自动重连时间，单位秒。
		 * 自动重连功能必须开启。
		 * 
		 * @type {Number}
		 */
		autoReconnectTime: 5,

		/**
		 * 连接成功的回调函数。
		 * 
		 * @type {Function}
		 * @return {void}
		 */
		onopen: null,

		/**
		 * 连接断开的回调函数。
		 * 
		 * @type {Function}
		 * @returnl {void}
		 */
		onclose: null,

		/**
		 * 连接异常的回调函数。
		 * 
		 * @type {Function}
		 * @return {void}
		 */
		onerror: null,
		
		/**
		 * 收到消息的回调函数。
		 * 
		 * @type {Function}
		 * @param {String} sAction
		 * @param {Object} oData
		 * @return {void}
		 */
		onmessage: null
	};


	/**
	 * webSocket 组件主体。
	 * 
	 * @param {Object} oConfigs 配置项。
	 * @return {Object} 
	 */
	function fnWebSocket(oConfigs) {
		// 合并参数。
		oConfigs = Object.assign({}, DEFAULT_CONFIGS, oConfigs);


		var 
			// 实例化的 WebSocket 对象。
			cSocket = null,

			// 自动重连的延迟器。
			nAutoReconnectTimeout = 0
		;


		// 开始执行。
		_render();
		
		
		// 公共属性或对象。
		var oPublic = {
			sendData: sendData,
			connect: connect,
			close: close
		};
		
		
		return oPublic;


		/**
		 * 执行入口。
		 * 
		 * @private
		 * @return {void}
		 */
		function _render() {
			// 浏览器兼容判断。
			if (!window.WebSocket) {
				alert("对不起，您当前的浏览器不支持 WebSocket\r\n请使用 Chrome、IE10、FireFoex 等高级浏览器访问");

				return;
			}


			// 初始化连接。
			_reconnect();
		}


		/**
		 * 初始化连接或重新连接。
		 * 
		 * @return {void}
		 */
		function _reconnect() {
			// 先关闭已有的。
			if (cSocket) {
				cSocket.close();
			}


			// 实例化 WebSocket 对象。
			cSocket = new WebSocket(oConfigs.url);


			// 监听事件。
			_addEventListeners();
		}
	
	
		/**
		 * 监听套接字事件。
		 * 
		 * @private
		 * @return {void}
		 */
		function _addEventListeners() {
			cSocket.addEventListener("open", _onopenHandler);
			cSocket.addEventListener("close", _oncloseHandler);
			cSocket.addEventListener("error", _onerrorHandler);
			cSocket.addEventListener("message", _onmessageHandler);
		}


		/**
		 * 连接成功的回调。
		 * 
		 * @private
		 * @param {SocketEvent} oEvent
		 * @return {void}
		 */
		function _onopenHandler(oEvent) {
			// 回调。
			oConfigs.onopen && oConfigs.onopen();
		}


		/**
		 * 套接字关闭时的事件句柄。
		 * 
		 * @private
		 * @param {SocketEvent} oEvent
		 * @return {void}
		 */
		function _oncloseHandler(oEvent) {
			// 回调。
			oConfigs.onclose && oConfigs.onclose();


			if (oConfigs.autoReconnect) {
				// 判断是已有重连定时器。
				if (!nAutoReconnectTimeout) {
					nAutoReconnectTimeout = setTimeout(function() {
						// 清除延迟标记。
						nAutoReconnectTimeout = 0;
						// 重连操作。
						_reconnect();
					}, oConfigs.autoReconnectTime * 1000);
				}
			}
		}
		
		
		/**
		 * 套接字连接异常时的事件句柄。
		 * 
		 * @private
		 * @param {SocketEvent} oEvent
		 * @return {void}
		 */
		function _onerrorHandler(oEvent) {
			// 回调。
			oConfigs.onerror && oConfigs.onerror();
		}
		
		
		/**
		 * 套接字收到信息时的事件句柄。
		 * 
		 * @private
		 * @param {SocketEvent} oEvent
		 * @return {void}
		 */
		function _onmessageHandler(oEvent) {
			/*
			 * 将数据转换成 Object 对象。
			 * 
			 * 数据结构：
			 * action {String} 数据类型。
			 * data {Object} 数据内容。
			 */
			var oSocketData = JSON.parse(oEvent.data);


			// 使用 action、data 数据回调。
			oConfigs.onmessage && oConfigs.onmessage(oSocketData.action, oSocketData.data);
		}


		/**
		 * 发送数据。
		 * 
		 * @param {String} sAction
		 * @param {Object} oData
		 * @return {void}
		 */
		function sendData(sAction, oData) {
			cSocket.send(JSON.stringify({
				action: sAction,
				data: oData
			}));
		}
		
		
		/**
		 * 连接套接字服务。
		 * 一般不需要主动调用，在调用组件的时候都会自动连接。
		 * 当手动关闭时，又想重连的，就可以调用。
		 * 
		 * @public
		 * @returnl {void}
		 */
		function connect() {
			_reconnect();
		}


		/**
		 * 关闭套接字连接。
		 * 
		 * @public
		 * @return {void}
		 */
		function close() {
			if (cSocket) {
				cSocket.close();
			}
		}
	}


	/**
	 * 解决冲突处理。
	 * 返回小工具对象，由开发人员自己处理。
	 *
	 * @method
	 * @return {Object}
	 */
	fnWebSocket.conflict = function() {
		window.util = _util;
		return oUtil;
	}


	var oUtil = window.util || {};
	oUtil.webSocket = fnWebSocket;
}))();